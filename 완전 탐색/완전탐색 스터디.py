# -*- coding: utf-8 -*-
"""연습용.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1cI7vkqxs5WMh_9o0NpCARdKUabvS0EOe

**모의고사**
"""

def solution(answers):
  hatemath_1=[1,2,3,4,5]*2000; hatemath_2=[2,1,2,3,2,4,2,5]*1250; hatemath_3=[3,3,1,1,2,2,4,4,5,5]*1000; result = []; 
  result.append(len([i for i, j in zip(answers, hatemath_1) if i == j]))
  result.append(len([i for i, j in zip(answers, hatemath_2) if i == j]))
  result.append(len([i for i, j in zip(answers, hatemath_3) if i == j]))
  return list(i+1 for i in range(3) if max(result) == result[i])

print(solution([1,2,3,4,5]))
print(solution([1,3,2,4,2]))

"""**최소직사각형**"""

def solution(sizes):
  width = []; height = []
  for size in sizes:
    size.sort(reverse=True)
    width.append(size[0])
    height.append(size[1])
  return max(width)*max(height)

print(solution([[60, 50], [30, 70], [60, 30], [80, 40]]))
print(solution([[10, 7], [12, 3], [8, 15], [14, 7], [5, 15]]))
print(solution([[14, 4], [19, 6], [6, 16], [18, 7], [7, 11]]))

#다른 사람 풀이 -> 내가 생각한 알고리즘을 한 줄로 줄임..ㅎ
# def solution(sizes):
#     return max(max(x) for x in sizes) * max(min(x) for x in sizes)

"""**소수찾기**"""

from itertools import permutations #파이썬으로 모든 조합 구하기
import math
def solution(numbers):
  number = list(map(str, numbers)) #문자열 리스트로 변환
  num_combin_1= list(permutations(number, 1)) #모든 조합
  num_combin_2= list(permutations(number, 2)) #모든 조합
  num_combin_3= list(permutations(number, 3)) #모든 조합
  num_combin_4= list(permutations(number, 4)) #모든 조합
  num_combin_5= list(permutations(number, 5)) #모든 조합
  num_combin_6= list(permutations(number, 6)) #모든 조합
  num_combin_7= list(permutations(number, 7)) #모든 조합
  num_int=[]; result=[];

  for i in num_combin_1: #문자열로 만들고 정수로 만들기 ex) [('1', '7')] -> "17" -> 17
    num_int.append(int(''.join(s for s in i)))

  for i in num_combin_2: #문자열로 만들고 정수로 만들기 ex) [('1', '7')] -> "17" -> 17
    num_int.append(int(''.join(s for s in i)))

  for i in num_combin_3: #문자열로 만들고 정수로 만들기 ex) [('1', '7')] -> "17" -> 17
    num_int.append(int(''.join(s for s in i)))

  for i in num_combin_4: #문자열로 만들고 정수로 만들기 ex) [('1', '7')] -> "17" -> 17
    num_int.append(int(''.join(s for s in i)))

  for i in num_combin_5: #문자열로 만들고 정수로 만들기 ex) [('1', '7')] -> "17" -> 17
    num_int.append(int(''.join(s for s in i)))

  for i in num_combin_6: #문자열로 만들고 정수로 만들기 ex) [('1', '7')] -> "17" -> 17
    num_int.append(int(''.join(s for s in i)))

  for i in num_combin_7: #문자열로 만들고 정수로 만들기 ex) [('1', '7')] -> "17" -> 17
    num_int.append(int(''.join(s for s in i)))
  num_int = list(set(num_int)) #중복 제거하기

  #소수인지 아닌지 판별
  for ele in num_int:
    if ele < 2:
      continue
    is_prime = True
    for j in range(2, ele):
      if ele % j == 0:
        is_prime = False
        break
    if is_prime:
      result.append(ele)
        
  return(len(result))

print(solution("17"))
print(solution("011"))
#print(solution("1234"))

#다른 사람 풀이1 -> 내 풀이를 매우 간소화 할 수 있는.......
#에라토스테네스 체를 set을 이용해서 씀..

# from itertools import permutations
# def solution(n):
#     a = set()
#     for i in range(len(n)):
#         a |= set(map(int, map("".join, permutations(list(n), i + 1))))
#     a -= set(range(0, 2))
#     for i in range(2, int(max(a) ** 0.5) + 1):
#         a -= set(range(i * 2, max(a) + 1, i))
#     return len(a)

"""**카펫**"""

def solution(brown, yellow): #가로x2+(세로-2)*2 = brown
  size = []
  for i in range(3,5000): #width
    for j in range(3,5000): #height
      if brown == (i*2)+(j*2-4) and i>=j: #가로 길이는 세로 길이와 같거나 큼
        if(i*j == brown+yellow):
          size.extend([i,j])
  return size

print(solution(10,2))
print(solution(8,1))
print(solution(24,24))

"""**모음사전**"""

#길이가 5이하의 모든 단어
#A,AA,AAA,AAAA,AAAAA,~ ,UUUUU
from itertools import product
def solution(word):
  #사전 정의, 중복 순열
  alpha_list = ['A', 'E', 'I', 'O', 'U']; diction_list=[]; new_diction_list = [];
  for i in range(1,6):  
    diction_list.extend(list(''.join(i) for i in list(product(alpha_list, repeat=i))))
  #정렬을 위해 5자리로 맞추고 거기에 0채우기 -> 아스키코드로 0이 A보다 작으니까 정렬하기 편함
  new_diction_list.extend(list( "{0:0<5}".format(i) for i in diction_list))
  
  #정렬하기..A,AA,AAA,AAAA,AAAAA,~ ,UUUUU
  new_diction_list.sort(key=lambda x : (x*5))
  #print(new_diction_list)
  #word도 공백에 0 채워서 사전에 있는 요소로 만들어준 다음에 인덱스 찾기..
  return(new_diction_list.index("{0:0<5}".format(word))+1) #인덱스는 0부터 시작하니까 1 더해주기

print(solution("AAAAE"))
print(solution("AAAE"))
print(solution("I"))
print(solution("EIO"))

#다른 사람의 풀이..1
#아니 어떻게 한 줄이 가능한거야
#나랑 거의 비슷하지만 오름차순으로 정렬..그냥 오름차순으로만 하면 된거였는데 무슨 뻘짓을 한거지지
# from itertools import product

# solution = lambda word: sorted(["".join(c) for i in range(5) for c in product("AEIOU", repeat=i+1)]).index(word) + 1

"""**전력망을 둘로 나누기**"""

#송전탑의 개수 n, 전선정보 wires, 길이 n-1
#
# def solution(n, wires):

# print(solution(9,[[1,3],[2,3],[3,4],[4,5],[4,6],[4,7],[7,8],[7,9]]))
# print(solution(4,[[1,2],[2,3],[3,4]]))
# print(solution(7,[[1,2],[2,7],[3,7],[3,4],[4,5],[6,7]]))

#다른 사람의 풀이..1
#전력망을 둘로 나누기 -> 재현님

from collections import deque

def bfs(node, tree, visited, wire, cnt):
    queue = deque()
    queue.append([node, tree, visited, wire])
    visited[node] = True

    while queue:
        node, tree, visited, wire = queue.popleft()
        cnt += 1

        for i in tree[node]:
            if not ((node == wire[0] and i == wire[1]) or (node == wire[1] and i == wire[0])):
                if not visited[i]:
                    visited[i] = True
                    queue.append([i, tree, visited, wire])

    return cnt


def solution(n, wires):
    answer = 1e9
    tree = [[] for _ in range(n + 1)]

    for wire in wires:
        a, b = wire
        tree[a].append(b)
        tree[b].append(a)

    for wire in wires:
        visited = [False] * (n + 1)
        temp = []
        for i in range(1, n + 1):
            if not visited[i]:
                cnt = bfs(i, tree, visited, wire, 0)
                temp.append(cnt)

        answer = min(answer, abs(temp[0] - temp[1]))

    return answer

print(solution(9, [[1,3],[2,3],[3,4],[4,5],[4,6],[4,7],[7,8],[7,9]]))
print(solution(4, [[1,2],[2,3],[3,4]]))
print(solution(7, [[1,2],[2,7],[3,7],[3,4],[4,5],[6,7]]))

"""**피로도**"""

#피로도 -> 재현님 코드
answer = 0
N = 0
visited = []

def dfs(k, cnt, dungeons):
    global answer
    if cnt > answer:
        answer = cnt

    for j in range(N):
        if k >= dungeons[j][0] and not visited[j]:
            visited[j] = 1
            dfs(k - dungeons[j][1], cnt + 1, dungeons)
            visited[j] = 0


def solution(k, dungeons):
    global N, visited
    N = len(dungeons)
    visited = [0] * N
    dfs(k, 0, dungeons)
    return answer

print(solution(80, [[80,20],[50,40],[30,10]])) 

#피로도->최영창창
from itertools import permutations

def solution(k, dungeons):
    cnt = len(dungeons)
    answer = []

    for i in permutations(dungeons, cnt):
        temp = k
        a = 0
        for j in i:
            if temp >= j[0]:
                temp -= j[1]
                a += 1
        answer.append(a)

    return max(answer)

print(solution(80, [[80,20],[50,40],[30,10]]))

# 피로도->지원
from itertools import permutations

def solution(k, dungeons):
    answer = 0
    dungeon_len = len(dungeons)

    for i in permutations(dungeons, dungeon_len):
        count = 0
        fatigue = k
        for j in i:
            if fatigue >= j[0]:
                fatigue-=j[1]
                count += 1
        if count > answer:
            answer = count
        if count == dungeon_len:
            return answer
    return answer

# k를 그냥 넣으니까 당연히 그 다음 i에서 안돌가가지 멍충앙
# j[0]번째는 조건 피로도, j[1]번째는 소모 피로도


print(solution(80, [[80,20],[50,40],[30,10]]))

#피로도 -> 영주

from itertools import permutations

def solution(k, dungeons):
    # 탐험 가능한 모든 경우
    case = list(permutations(dungeons, len(dungeons)))
    answer = 0   # 탐험 가능한 최대 던전 수

    # 각 순서마다 탐험 가능한 던전 수 확인
    for i in case:
        hp = k   # 피로도, 던전 수 초기화
        count = 0

        # 탐험 던전 수, 소모 피로도 계산
        for j in i:
            if hp >= j[0]:
                count += 1
                hp -= j[1]

        # 큰 값의 탐험 던전 수 저장
        answer = max(answer, count)

    return answer

print(solution(80,     [[80,20],[50,40],[30,10]]))