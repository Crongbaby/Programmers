# -*- coding: utf-8 -*-
"""연습용.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1cI7vkqxs5WMh_9o0NpCARdKUabvS0EOe
"""

def solution(number, limit, power):
  #N = A * B 로 나타낼 수 있다는 것을 이용한 풀이이다. 항상 약수를 구하면 그 짝이 되는 수가 존재
  #for 문을 이용해 자연수 N의 제곱근까지의 약수를 구하면 그 짝이 되는 약수는 자동으로 구할 수 있음.
  #N = A * B 일 때,  A == B 일 수 있기 때문에 (ex. 25 = 5 * 5 ) 값을 중복해서 넣어주지 않기 위해 
  #if 문으로 제곱했을 때 n이 되지 않는지 검사

  def getMyDivisor(n): #약수 구하기

    divisorsList = []
    for i in range(1, int(n**(1/2)) + 1):
        if (n % i == 0):
            divisorsList.append(i) 
            if ( (i**2) != n) : 
                divisorsList.append(n // i)
    
    return len(divisorsList)

  result = 0
  for i in range(1,number+1):
    before_power = getMyDivisor(i) #약수의 개수.
    if before_power > limit:
      result += power
    else:
      result += before_power

  return result

print(solution(5,3,2))
print(solution(10,3,2))

#다른 사람의 코드1...나에 비해서 너무 간단한데....
#리스트 축약 안하고 풀어쓰면 2배 빨라질지도?
def cf(n): # 공약수 출력
    a = []
    for i in range(1,int(n**0.5)+1):
        if n%i == 0:
            a.append(n//i)
            a.append(i)
    return len(set(a))
def solution(number, limit, power):
    return sum([cf(i) if cf(i)<=limit else power for i in range(1,number+1)])

#다른 사람의 풀이2....
def solution(number, limit, power):
    divisor_num = []
    for j in range(1, number+1):
        cnt = 0
        for i in range(1, int(j**0.5) +1 ):
            if (j == i**2):
                cnt +=1
            elif (j%i == 0):
                cnt +=2
        divisor_num.append(cnt)
    res = [i if i <= limit else power for i in divisor_num ]
    return sum(res)