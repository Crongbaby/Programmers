# -*- coding: utf-8 -*-
"""연습용.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1cI7vkqxs5WMh_9o0NpCARdKUabvS0EOe
"""

# def solution(N, stages): #런타임 에러가 너무 나서 다른 풀이로 해야지...
#   fail_per = {} #실패율 담긴 딕셔너리
#   for i in range(1,N+1):
#     count = 0
#     for j in stages:
#       if (j <= i):
#         count+=1
#     fail_per[i] = count/(len(stages))
#     stages = list(filter(lambda x: x > i, stages))  #런타임 에러
#   new_fail = sorted(fail_per.items(),key= lambda x : x[1],reverse = True) #런타임 에러
#   return([i[0] for i in new_fail])

def solution(N, stages): #위에 코드가 런타임 에러가 너무 나서 다른 풀이로 해야지...
  fail_per = {} #실패율 담긴 딕셔너리
  length = len(stages) 
  for i in range(1,N+1):
    if(length!=0):
      fail_per[i] = stages.count(i)/length #원래 이거 썼다가 버렸는데 역시 유용하네
      length -= stages.count(i) #filter 함수 대신 간단하게 구현
    else:
      fail_per[i] = 0
  return(sorted(fail_per,key = lambda x : fail_per[x],reverse = True))  

print(solution(5,[2, 1, 2, 6, 2, 4, 3, 3]))
print(solution(4,	[4,4,4,4,4]))

#다른 사람의 풀이1....시간이 짧음
def solution(N, stages):
    answer = []
    fail = []
    info = [0] * (N + 2)
    for stage in stages:
        info[stage] += 1
    for i in range(N):
        be = sum(info[(i + 1):])
        yet = info[i + 1]
        if be == 0:
            fail.append((str(i + 1), 0))
        else:
            fail.append((str(i + 1), yet / be))
    for item in sorted(fail, key=lambda x: x[1], reverse=True):
        answer.append(int(item[0]))
    return answer