# -*- coding: utf-8 -*-
"""연습용.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1cI7vkqxs5WMh_9o0NpCARdKUabvS0EOe
"""

def solution(sizes):
  width = []; height = []
  for size in sizes:
    size.sort(reverse=True)
    width.append(size[0])
    height.append(size[1])
  return max(width)*max(height)

print(solution([[60, 50], [30, 70], [60, 30], [80, 40]]))
print(solution([[10, 7], [12, 3], [8, 15], [14, 7], [5, 15]]))
print(solution([[14, 4], [19, 6], [6, 16], [18, 7], [7, 11]]))

#다른 사람 풀이 -> 내가 생각한 알고리즘을 한 줄로 줄임..ㅎ
# def solution(sizes):
#     return max(max(x) for x in sizes) * max(min(x) for x in sizes)

#람다를 이렇게 구현할 수 있음
# sum(덧셈할 것, 처음에 더할 것) => 2차원 리스트들이 sum함수에 의해서 1차원 리스트로 연결
# my_list = [[7, 6], [5, 4], [1, 2, 3], ['a', 'b']]
# result = sum(my_list, [])
# print(result) #[7, 6, 5, 4, 1, 2, 3,'a', 'b']

#위의 문법을 이용한 다른 사람의 풀이2 
#[[]] 2차원 리스트를 sum으로 1차원으로 바꾸고, 그 중에서 최대값 * 2차원 리스트 안에 리스트들 중에서 최솟값 중에 최대 => 내가 생각한 알고리즘 완벽 구현현
# solution = lambda sizes: max(sum(sizes, [])) * max(min(size) for size in sizes)